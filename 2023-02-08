프로세스 : 실행중인 프로그램
백그라운드 프로세스 / 포그라운드 프로세스
사용자와 상호작용하지 않고 묵묵히 정해진 일만 하는 백그라운드프로세스 - 서비스... 유닉스 체계는 데몬

프로세스 제어 블록 - 모든 프로세스는 CPU를 필요로 하지만 CPU의 자원은 한정적... 차례대로 돌아가며 한정된 시간만큼 CPU 사용.
인터럽트(타이머 인터럽트 == 타임아웃 인터럽트) 발생 시 자신의 차례를 양보하고 다음 차례가 올 때 까지 대기
운영체제는 빠르게 번갈아 수행되는 프로세스의 실행 순서를 관리하고 프로세스에 CPU를 비롯한 자원을 배분 - 여기서 프로세스 제어 블록 이용

프로세스 제어 블록은 프로세스와 관련된 정보를 저장하는 자료 구조. 해당 프로세스를 식별하기 위해 꼭 필요한 정보들이 저장
PCB는 커널 영역에 생성... like 옷의 태그... 
PCB는 프로세스 생성 시에 만들어지고 실행이 끝나면 폐기...
- 프로세스 ID(PID) - 프로세스를 식별하기 위한 고유 번호
- 레지스터 값 - 자신의 실행 차례가 돌아오면 이전까지 사용했던 레지스터의 값들을 모두 복원... 그래야 이전 작업들을 그대로 이어 실행 가능
- 프로세스 상태 - 현재 프로세스의 상태
- CPU 스케쥴링 정보
- 메모리 관리 정보 - 프로세스가 메모리의 어느 주소에 저장되어 있는지 정보. 베이스 레지스터, 한계 레지스터, 페이지 테이블 정보 등
- 사용한 파일과 입출력 장치 목록
운영체제는 커널 영역에 적재된 PCB를 보고 프로세스를 관리

문맥 교환
문맥 : 중간정보... 즉 하나의 프로세스 수행을 재개하기 위해 기억해야 할 정보(PCB에 저장)
기존 프로세스의 문맥을 PCB에 백업하고 새로운 프로세스를 실행하기 위해 문맥을 PCB로부터 복구하여 새로운 프로세스를 실행하는 것을 문맥 교환...
문맥교환이 많으면 오버헤드가 발생할 수 있기에 무조건 좋은건 아님.

프로세스 메모리 영역 - 커널영역에는 PCB가 생성... 그럼 사용자 영역에서는?? 코드 영역, 데이터 영역, 힙 영역, 스택 영역...
코드 영역 == 텍스트 영역 - 말 그대로 실행할 수 있는 코드, 즉 기계어로 이루어진 명령어. 읽기 전용 공간. 쓰기 X
데이터 영역 - 잠깐 썻다가 없앨 데이터가 아닌 프로글매이 실행되는 동안 유지할 데이터가 저장... 전역 변수(프로그램이 실행되는 동안 유지되며 프로그램 전체에서 접근 가능한 변수)
이 두 영역은 정적 할당 영역... 명령어가 바뀔 일 이 없고 데이터는 프로그램이 실행되는 동안만 유지

힙영역 - 프로그램을 만드는 사용자가 직접 할당할 수 있는 저장 공간. 메모리 공간을 할당했다면 언젠가는 반환해야 함. 더 이상 해당 메모리 공간을 사용하지 않겠다라고 운영체제에 말해줌
반환하지 않는다면 메모리 누수... 메모리 낭비...
스택 영역 - 데이터를 일시적으로 저장하는 공간. 지역변수, 매개변수.

프로세스 상태 - 프로세스는 여러 상태를 거치며 실행된다. 운영체제는 PCB에 저장된 프로세스의 상태를 통해 인식하고 관리.
생성 상태 - 생성중인 상태. 이제 막 메모리에 적재되어 PCB를 할당받은 상태 -> 준비상태. 당장이라도 CPU할당 받을 수 있지만 자기 차례가 아니기에 기다리는 상태
->(디스패치) 실행 상태 - CPU를 할당받아 실행 중인 상태. 일정 시간 동안만 CPU 사용 가능. -> 대기 상태 - 프로세스 실행 도중 입출력 장치를 사용하는 경우 작업을 기다리는 상태...
-> 종료상태 - 프로세스가 종료. 운영체제는 PCB와 프로세스가 사용한 메모리를 정리
프로세스 상태 다이어 그램!! - 생성, 준비, 실행, 대기, 종료 (대기상태는 특정 이벤트를 기다리는 상태.. 일반적으로는 입출력 기다림이 많음)

프로세스 계층 구조
프로세스는 실행 도중 시스템 호출을 통해 다른 프로세스를 생성할 수 있음.
프로세스 생성 기법 : fork 시스템 호출을 통해 자신의 복사본을 자식 프로세스로 생성 // 자식  프로세스는 exec를 통해 자신의 메모리 공간을 다른 프로그램으로 교체 - 두개다 시스템콜

스레드 : 프로세스를 구성하는 실행의 흐름 단위
프로세스와 스레드... 한번에 하나의 부분만 실행? 단일 스레드 프로세스
스레드마다 각기 다른 코드를 실행... 프로세스의 스레드들은 실행에 필요한 최소한의 정보만을 유지한 채 프로세스 자원을 공유하며 실행.
스레드는 프로세스를 구성하는 실행의 흐름의 단위다. CPU는 작업을 전달할 때 프로세스가 아닌 스레드 단위로 전달. 스레드는 꼭 필요한 정보만 갖고 프로세스의 자원을 공유한다.

멀티 프로세스와 멀티 스레드
프로세스를 동시에 실행하는 것을 멀티프로세스... 여러 스레드로 프로세스를 동시에 실행하는 것을 멀티 스레드

멀티 스레드 이점... 프로세스의 자원을 공유하다보니 메모리를 효율적으로 사용 가능함.. fork시 저장된 메모리, pid를 제외한 동일한 데이터가 적재 - 비효율적
단점 : 멀티 프로세스 환경에서는 하나의 프로세스에 문제가 생겨도 다른 프로세스에 지장이 적음. 허나 멀티 스레드는 하나의 스레드에 문제가 생기면 전체 프로세스에 문제가 생길 수 있음.
왜냐면 프로세스의 자원을 공유하고 하나의 스레드에 문제가 생기면 다른 스레드도 영향을 받음

프로세스간 기본적으로는 자원을 공유하지 않지만! IPC 프로세스간 자원을 공유하고 데이터를 주고받을 수 있음. 프로세스간 통신 - 파일을 통한 프로세스 통신. 공유 메모리.






