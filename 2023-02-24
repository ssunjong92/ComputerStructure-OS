프로세스에 연속적인 메모리 공간을 할당하는 방식 - 연속 메모리 할당
스와핑 : 메모리에 적재된 프로세스중 현재 실행하지 않는 프로세스들(대기 상태 프로세스, 오랫동안 사용하지 않은 프로세스)을 임시로 보조기억장치로 이동시키고 
        메모리 상에 빈 공간에 다른 프로세스를 적재하여 실행. 보조기억 장치의 일부 영역을 스왑 영역. 스왑 아웃, 스왑 인. 
        스왑 아웃된 프로세스가 스왑 인 할때 물리 주소와는 다른곳에 적재 될 수 있따.
즉 메모리에서 사용하지 않는 프로세스를 보조기억장치로 내보내고 실행할 프로세스를 메모리로 옮기는 메모리 관리 기법.

메모리 할당하는 방식 : 최초, 최적, 최악 적합
최초 : 빈 공간 발견시 즉시... 검색 최소화, 빠른 할당 가능
최적 : 빈 공간 모두 검색 후 적재될 수 있는 공간 중 가장 작은 공간에 배치
최악 : 빈 공간 모두 검색 후 적재될 수 있는 공간 중 가장 큰 공간에 배치

외부 단편화 : 연속 메모리 할당은 좋아보이나 효율적인 방법이 아님... 왜냐?
프로세스들이 실행하고 종료하다보면 프로세스간 사이에 빈 공간들이 발생. 빈 공간이지만 그 공간보다 큰 프로세스들이 적재되기 어려움. 결국 메모리 낭비...
즉 프로세스를 할당하기 어려울만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상

해결방안? 
압축,,, 메모리 내 프로세스들을 적당히 재배치하여 흩어진 메모리 공간들을 하나의 큰 빈 메모리 공간으로 만들어줌. 그동안 시스템은 하던일을 멈춰야하고 메모리에 있는 내용을 옮기며 많은
오버헤드를 야기, 어떤 프로세스를 어떻게 옮겨야 오버헤드를 최소화 할 수 있는지의 방법이 불명확. 따라서 가상 메모리 기법 등장... 페이징!

연속 메모리 할당 기법의 문제... 외부 단편화가 발생, 메모리보다 큰 크기의 프로세스는 실행할 수 없음.
가상 메모리 - 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실행하는 기술... 페이징과 세그멘테이션
외부단편화의 근본적인 이유는? 서로 다른 크기의 프로세스가 메모리에 연속적으로 적재되어있기 때문.

페이징 - 프로세스의 논리 주소 공간을 페이지라는 단위로 자르고, 메모리 물리 주소 공간을 프레임이라는 페이지와 같은 크기의 일정한 단위로 자른 뒤 
페이지를 프레임에 할당하는 가상 메모리 관리 기법. 스와핑이 가능하고 프로세스 전체가 아닌 페이지 단위로 스왑이 됨.
페이지 테이블 - 프로세스가 메모리에 불연속적으로 되어 있으면 CPU입장에선 이를 순차적으로 실행하기 어려움. 그래서 물리 주소는 연속적이지 않더라도 논리 주소가 연속적으로 배치되도록
               페이지 테이블을 사용. 어떤 페이지가 어떤 프레임에 할당되었는지 알려줌.
내부 단편화 - 페이징은 내부 단편화를 야기할 수 있음. 프로세스의 크기가 페이지의 배수가 아님... 프로세스가 108kb고 페이지 크기가 10kb 면 2kb의 메모리 낭비...
             내부 단편화는 페이지 단위 크기보다 작게 발생. 너무 작게 단위를 하면 페이지 테이블의 크기가 커짐. 너무 단위를 크게하면 내부 단편화가 심하게 발생
프로세스 마다 프로세스 테이블을 가지고 있고 각 프로세스의 페이지 테이블들은 메모리에 적재. CPU 내의 페이지 테이블 베이스 레지스터는 각 프로세스의 페이지 테이블이 적재된 주소를 가르킴
위와 같은 경우 메모리 접근 시간이 두배... 페이지테이블 보기위해 한번, 이걸 통해 알게 된 프레임에 한번,,, 
TLB라는 페이지 테이블의 캐시 메모리를 둠. 참조지역성에 근거해 주로 사용된 페이지 위조로 가져와 저장
